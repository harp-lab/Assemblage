"""
A script to calculate the LZJD distance between 2 given binaries
https://github.com/EdwardRaff/pyLZJD

Yihao Sun
"""

import argparse
from difflib import SequenceMatcher
from glob import glob
import os
import shutil
import zipfile

import pyLZJD


def lzjd_distance(bin1, bin2):
    """ calculate the LZJD distance between 2 binaries """
    bin1_hash = pyLZJD.digest(os.path.realpath(bin1), mode='sh')
    bin2_hash = pyLZJD.digest(os.path.realpath(bin2), mode='sh')
    return 1.0 - pyLZJD.sim(bin1_hash[0], bin2_hash[0])


def longest_sequence_match(asm1, asm2):
    """ calculate the longest sequence based string similarity on linear disasmed binary """
    asm_text1 = ""
    asm_text2 = ""
    with open(asm1, 'r') as asm_f1:
        asm_text1 = asm_f1.read()
    with open(asm2, 'r') as asm_f2:
        asm_text2 = asm_f2.read()
    return 1 - SequenceMatcher(None, asm_text1, asm_text2).quick_ratio()


def compare_dir(dir1, dir2, metric):
    """ compare the data generated by assemblage under 2 different dir (subdir included) """
    # unzip to folder first
    if (not os.path.isdir(dir1)) or (not os.path.isdir(dir2)):
        print("not a file path!")
        return
    files_dir1 = os.listdir(dir1)
    files_dir2 = os.listdir(dir2)
    for build_res_name in files_dir1:
        if not build_res_name in files_dir2:
            print(f"build result {build_res_name} only exists in {dir1}")
            continue
        if os.path.isdir(os.path.join(dir1, build_res_name)):
            target1_folder = os.path.join(dir1, build_res_name)
            target2_folder = os.path.join(dir2, build_res_name)
        elif build_res_name.endswith('.zip'):
            target1_folder = os.path.join(dir1, build_res_name[:-4])
            target2_folder = os.path.join(dir2, build_res_name[:-4])
            with zipfile.ZipFile(os.path.join(dir1, build_res_name), 'r') as zip_f:
                if os.path.exists(target1_folder):
                    shutil.rmtree(target1_folder)
                zip_f.extractall(target1_folder)
            with zipfile.ZipFile(os.path.join(dir2, build_res_name), 'r') as zip_f:
                if os.path.exists(target2_folder):
                    shutil.rmtree(target2_folder)
                zip_f.extractall(target2_folder)
        else:
            continue
        for bin_path in glob(f"{target1_folder}/*"):
            # NOTE: Only compare windows binary !!!
            if (bin_path.endswith(".dll") or bin_path.endswith(".exe")) and \
                 metric == 'lzjd':
                rel_fpath = bin_path[len(target1_folder)+1:]
                bin2_path = os.path.join(target2_folder, rel_fpath)
                distance = lzjd_distance(bin_path, bin2_path)
                if distance == 0:
                    print(f"same file {bin_path}")
                    continue
                print(f"{bin_path} has LZJD distance \033[91m {distance} \033[0m")
            if (bin_path.endswith(".dll.asm") or bin_path.endswith(".exe.asm")) and \
                 metric == 'longest':
                rel_fpath = bin_path[len(target1_folder)+1:]
                bin2_path = os.path.join(target2_folder, rel_fpath)
                distance = longest_sequence_match(bin_path, bin2_path)
                if distance == 0:
                    print(f"same file {bin_path}")
                    continue
                print(f"{bin_path} has longest sequence matching ratio\033[91m {distance} \033[0m")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="calculate the binary distance "
                                                 "between 2 given binaries")
    parser.add_argument('bin1', metavar='bin1', type=str,
                        help="First binary/dir")
    parser.add_argument('bin2', metavar='bin2', type=str,
                        help="Second binary/dir")
    parser.add_argument('metric', metavar='metric', type=str,
                        help="binary distance metrics, now avaliable metrics are"
                             "longest(longest distance)\n lzjd(LZJD distance).")
    supported_metrics = ['lzjd', 'longest']
    arg = parser.parse_args()
    if arg.metric not in supported_metrics:
        print("metric not supported. avaliable metrics:")
        print(supported_metrics)
    if (not os.path.isdir(arg.bin1)) and (not os.path.isdir(arg.bin2)):
        print(lzjd_distance(arg.bin1, arg.bin2))
    else:
        compare_dir(arg.bin1, arg.bin2, arg.metric.strip())
